generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}


model Organization {
  id                      String      @id @default(uuid()) @unique 
  name                    String?      @db.VarChar(255)          
  address                 String?      @db.VarChar(255)          
  email                   String       @db.VarChar(255)   @unique                       
  phone                   String?      @db.VarChar(255)                         
  postalCode              String?      @db.VarChar(255)  
  city                    String?      @db.VarChar(255)  
  country                 String?      @db.VarChar(255)  
  website                 String?      @db.VarChar(255)
  taxID                   String?      @db.VarChar(255)
  isFilledByOrg           Boolean      @default(false)
  bankDetailsId           String?      @unique
  users                   User[] @relation("OrganizationUsers") // Many-to-Many relation
  teamId                  String?     
  team                    Teams?              @relation(fields: [teamId], references: [id])   
  bankDetails             BankDetails?        @relation(fields: [bankDetailsId], references: [id])
  fundingRequests         FundingRequest[]                
  Files                   File[]                    
  donationAgreements      DonationAgreement[]
  

  createdAt               DateTime    @default(now()) @db.Timestamptz(6) 
  updatedAt               DateTime    @updatedAt @db.Timestamptz(6) 


  Transaction Transaction[]
}


model BankDetails {
  id              String     @id @default(uuid()) @unique       
  bankName        String     @db.VarChar(255)                  
  accountHolder   String     @db.VarChar(255)                  
  iban            String     @db.VarChar(255)     @unique                
  bic             String     @db.VarChar(255)                
  createdAt       DateTime @default(now()) @db.Timestamptz(6) 
  updatedAt       DateTime @updatedAt @db.Timestamptz(6) 
  organization    Organization? @relation
  teams           Teams? @relation 
}



enum FundingStatus {
  Submitted
  Accepted
  WaitingForSignature
  Approved
  FundsDisbursing
  Completed
  Rejected


  // remove below
  UnderReview
  Pending
  Processing 
  FundsTransferred
}
model FundingRequest {
  id                        String    @id @default(uuid()) @unique   
  name                      String      @db.VarChar(255) 
  organizationId            String                                
  organization              Organization @relation(fields: [organizationId], references: [id])
  description               String       @db.Text                   
  purpose                   String       @db.Text
  amountRequested           Decimal                                 
  amountAgreed              Decimal?                              
  remainingAmount           Decimal?    
  refinancingConcept        String       @db.Text
  sustainability            String       @db.Text
  expectedCompletionDate    DateTime                               
  status                    FundingStatus @default(Submitted)   
  submittedById             String           
  submittedBy               User? @relation(fields: [submittedById], references: [id])
  customFields              Json?                                  // Store dynamic field data as JSON
  createdAt                 DateTime @default(now()) @db.Timestamptz(6) 
  updatedAt                 DateTime @updatedAt @db.Timestamptz(6) 
  files                     File[]          
  teamId                    String?
  team                      Teams? @relation(fields: [teamId], references: [id])
  donationAgreement         DonationAgreement[]
  Transaction Transaction[]
}

model File {
  id          String    @id @default(uuid()) @unique 
  name        String?      @db.VarChar(255)  
  url         String      @unique
  type        String      @db.VarChar(255)                             
  createdBy   User @relation("CreatedByRelation", fields: [createdById], references: [id])
  createdById String                       
  updatedBy   User @relation("UpdatedByRelation", fields: [updatedById], references: [id])
  updatedById String               
  createdAt   DateTime    @default(now()) @db.Timestamptz(6)
  updatedAt   DateTime    @updatedAt @db.Timestamptz(6) 

  organizationId String?  @db.VarChar(255)  
  organization   Organization? @relation(fields: [organizationId], references: [id])  // One-to-Many relation
  fundingRequestId String?
  FundingRequest FundingRequest? @relation(fields: [fundingRequestId], references: [id])
  donationAgreement DonationAgreement[]


  Transaction Transaction[]
}

enum Roles {
  Organization
  Team
  Admin
}


model Teams {
  id          String           @id @default(uuid()) @unique
  name        String           @unique
  email       String           @db.VarChar(255) @unique
  phone       String?          @db.VarChar(255)
  address     String?          @db.VarChar(255)
  postalCode  String?          @db.VarChar(255)
  city        String?          @db.VarChar(255)
  country     String?          @db.VarChar(255)
  website     String?          @db.VarChar(255)
  strategicPriorities String?  @db.Text

  bankDetailsId String?        @unique
  bankDetails   BankDetails?   @relation(fields: [bankDetailsId], references: [id])
  organizations Organization[]

  users     User[] @relation("TeamUsers") // Many-to-Many relation
  fundingRequests    FundingRequest[]
  donationAgreements DonationAgreement[]
  createdAt    DateTime        @default(now()) @db.Timestamptz(6)
  updatedAt    DateTime        @updatedAt @db.Timestamptz(6)

  emailTemplates emailTemplates[]
  formSections FormSection[]

  Transaction Transaction[]
  contacts     Contact[]
  contactLists ContactList[]
  events       Event[]
  eventRoles   EventRole[]
  groups       Group[]
}

model User {
  id             String           @id @default(uuid()) @unique
  name           String?          @db.VarChar(255)
  address        String?          @db.VarChar(255)
  email          String           @db.VarChar(255) @unique
  phone          String?          @db.VarChar(255)
  postalCode     String?          @db.VarChar(255)
  city           String?          @db.VarChar(255)
  country        String?          @db.VarChar(255)
  roles          Roles[]
  emailVerified DateTime?
  image         String?

  fundingRequests FundingRequest[]
  teams           Teams[]          @relation("TeamUsers") // Many-to-Many relation
  organizations   Organization[]   @relation("OrganizationUsers") // Many-to-Many relation
  groups          UserGroup[]      // Many-to-Many relation through UserGroup

  signedAgreements DonationAgreementSignature[]
  donationAgreement DonationAgreement[] @relation("CreatedByRelation")

  createdBy       File[]           @relation("CreatedByRelation") // One-to-Many relation
  updatedBy       File[]           @relation("UpdatedByRelation") // One-to-Many relation
  accounts      Account[]
  sessions      Session[]


  createdAt      DateTime         @default(now()) @db.Timestamptz(6)
  updatedAt      DateTime         @updatedAt @db.Timestamptz(6)

}

model DonationAgreement {
  id               String    @id @default(uuid()) @unique
  fundingRequestId String
  fundingRequest   FundingRequest @relation(fields: [fundingRequestId], references: [id])

  fileId           String
  file             File      @relation(fields: [fileId], references: [id])
  agreement        String    @db.Text

  createdBy        User @relation("CreatedByRelation", fields: [createdById], references: [id])
  createdById      String
  userSignatures DonationAgreementSignature[]
  teamId           String?
  team             Teams? @relation(fields: [teamId], references: [id])
  organizationId           String?
  organization             Organization? @relation(fields: [organizationId], references: [id])

  createdAt        DateTime  @default(now()) @db.Timestamptz(6)
  updatedAt        DateTime  @updatedAt @db.Timestamptz(6)
}

model DonationAgreementSignature {
  donationAgreementId String
  userId              String
  signedAt            DateTime?  // If NULL, person hasn't signed

  donationAgreement DonationAgreement @relation(fields: [donationAgreementId], references: [id], onDelete: Cascade)
  user     User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([donationAgreementId, userId]) // Composite key to avoid duplicate signatures
}

enum ContactAttributeType {
  STRING
  NUMBER
  DATE
  LOCATION
}

enum AppModule {
  CRM
  FUNDING
}

model Contact {
  id                String               @id @default(uuid()) @unique
  teamId            String
  team              Teams                @relation(fields: [teamId], references: [id], onDelete: Cascade)
  name              String
  pronouns          String?             @db.VarChar(120)
  city              String?             @db.VarChar(255)
  email             String?              @db.VarChar(255)
  phone             String?              @db.VarChar(255)
  groupId           String?              // Optional group for access control
  group             Group?               @relation(fields: [groupId], references: [id], onDelete: SetNull)
  createdAt         DateTime             @default(now()) @db.Timestamptz(6)
  updatedAt         DateTime             @updatedAt @db.Timestamptz(6)
  attributes        ContactAttribute[]
  events            EventContact[]
  registrations     EventRegistration[]
  engagements       ContactEngagement[]
  changeLogs        ContactChangeLog[]
  lists             ContactListMember[]

  @@index([groupId])
  @@index([teamId, groupId])
  @@unique([teamId, email])
}

enum ContactListType {
  MANUAL
  SMART
}

model ContactList {
  id          String              @id @default(uuid()) @unique
  teamId      String
  team        Teams               @relation(fields: [teamId], references: [id], onDelete: Cascade)
  name        String              @db.VarChar(255)
  description String?             @db.Text
  type        ContactListType     @default(MANUAL)
  filters     Json?               @db.JsonB
  createdAt   DateTime            @default(now()) @db.Timestamptz(6)
  updatedAt   DateTime            @updatedAt @db.Timestamptz(6)
  contacts    ContactListMember[]

  @@index([teamId])
}

model ContactListMember {
  id          String      @id @default(uuid()) @unique
  listId      String
  list        ContactList @relation(fields: [listId], references: [id], onDelete: Cascade)
  contactId   String
  contact     Contact     @relation(fields: [contactId], references: [id], onDelete: Cascade)
  createdAt   DateTime    @default(now()) @db.Timestamptz(6)

  @@unique([listId, contactId])
  @@index([listId])
  @@index([contactId])
}

model ContactAttribute {
  id            String                @id @default(uuid()) @unique
  contactId     String
  contact       Contact               @relation(fields: [contactId], references: [id], onDelete: Cascade)
  key           String                @db.VarChar(255)
  type          ContactAttributeType
  stringValue   String?               @db.Text
  numberValue   Decimal?
  dateValue     DateTime?             @db.Timestamptz(6)
  locationLabel String?               @db.VarChar(255)
  latitude      Decimal?
  longitude     Decimal?
  createdAt     DateTime              @default(now()) @db.Timestamptz(6)
  updatedAt     DateTime              @updatedAt @db.Timestamptz(6)

  @@index([key])
  @@unique([contactId, key])
}


model emailTemplates {
  id String @id @default(uuid()) @unique
  name String @db.VarChar(255)
  subject String @db.VarChar(255)
  content String @db.Text
  type String @db.VarChar(255)
  isActive Boolean @default(true)
  teamId String?
  team Teams? @relation( fields: [teamId],references: [id], onDelete: Cascade)
  createdAt DateTime @default(now()) @db.Timestamptz(6)
  updatedAt DateTime @updatedAt @db.Timestamptz(6)
  
}

enum FieldType {
  TEXT
  TEXTAREA
  NUMBER
  DATE
  EMAIL
  URL
  SELECT
  MULTISELECT
  CHECKBOX
  RADIO
  FILE
}

model FormSection {
  id String @id @default(uuid()) @unique
  name String @db.VarChar(255)
  description String? @db.Text
  order Int
  teamId String?
  team Teams? @relation(fields: [teamId], references: [id], onDelete: Cascade)
  fields FormField[]
  createdAt DateTime @default(now()) @db.Timestamptz(6)
  updatedAt DateTime @updatedAt @db.Timestamptz(6)
}

model FormField {
  id String @id @default(uuid()) @unique
  key String @db.VarChar(255)
  label String @db.VarChar(255)
  description String? @db.Text
  type FieldType
  placeholder String? @db.VarChar(255)
  defaultValue String? @db.Text
  isRequired Boolean @default(false)
  order Int
  
  // Validation rules
  minLength Int?
  maxLength Int?
  minValue Decimal?
  maxValue Decimal?
  pattern String? @db.VarChar(255)
  
  // Select/Radio options (JSON array of {label: string, value: string})
  options Json?
  
  sectionId String
  section FormSection @relation(fields: [sectionId], references: [id], onDelete: Cascade)
  
  createdAt DateTime @default(now()) @db.Timestamptz(6)
  updatedAt DateTime @updatedAt @db.Timestamptz(6)
  
  @@unique([sectionId, key])
}




model Transaction {
  id String @id @default(uuid()) @unique
  amount Decimal
  totalAmount Decimal
  remainingAmount Decimal
  transactionReciept String? 
  fundingRequestId String
  fundingRequest FundingRequest @relation(fields: [fundingRequestId], references: [id])
  organizationId String
  organization Organization @relation(fields: [organizationId], references: [id])
  teamId String
  
  team Teams @relation(fields: [teamId], references: [id])  
  file File? @relation(fields: [transactionReciept], references: [id], onDelete: SetNull, onUpdate: SetNull)

  createdAt DateTime @default(now()) @db.Timestamptz(6)
  updatedAt DateTime @updatedAt @db.Timestamptz(6)
}

model Account {
  id                 String  @id @default(cuid())
  userId             String  
  type               String
  provider           String
  providerAccountId  String  
  refresh_token      String? @db.Text
  access_token       String? @db.Text
  expires_at         Int?
  token_type         String?
  scope              String?
  id_token           String? @db.Text
  session_state      String?
 
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
 
  @@unique([provider, providerAccountId])
}
 
model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique 
  userId       String  
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
 
}
 

model VerificationToken {
  identifier String
  token      String
  expires    DateTime

  @@unique([identifier, token])
}

model Event {
  id            String              @id @default(uuid()) @unique
  teamId        String
  team          Teams               @relation(fields: [teamId], references: [id], onDelete: Cascade)
  title         String              @db.VarChar(255)
  slug          String?             @db.VarChar(255)
  description   String?             @db.Text
  location      String?             @db.VarChar(255)
  startDate     DateTime            @db.Timestamptz(6)
  endDate       DateTime?           @db.Timestamptz(6)
  isPublic      Boolean             @default(false)
  createdAt     DateTime            @default(now()) @db.Timestamptz(6)
  updatedAt     DateTime            @updatedAt @db.Timestamptz(6)
  contacts      EventContact[]
  registrations EventRegistration[]

  @@unique([teamId, slug])
  @@index([teamId])
  @@index([slug])
}

model EventContact {
  eventId      String
  contactId    String
  event        Event        @relation(fields: [eventId], references: [id], onDelete: Cascade)
  contact      Contact      @relation(fields: [contactId], references: [id], onDelete: Cascade)
  roles        EventContactRole[]

  @@id([eventId, contactId])
  @@index([eventId])
  @@index([contactId])
}

model EventContactRole {
  eventId      String
  contactId    String
  eventRoleId  String
  eventContact EventContact @relation(fields: [eventId, contactId], references: [eventId, contactId], onDelete: Cascade)
  eventRole    EventRole    @relation(fields: [eventRoleId], references: [id], onDelete: Cascade)

  @@id([eventId, contactId, eventRoleId])
}

model EventRole {
  id        String    @id @default(uuid()) @unique
  teamId    String
  team      Teams     @relation(fields: [teamId], references: [id], onDelete: Cascade)
  name      String    @db.VarChar(255)
  color     String?   @db.VarChar(50)
  createdAt DateTime  @default(now()) @db.Timestamptz(6)
  updatedAt DateTime  @updatedAt @db.Timestamptz(6)
  contacts  EventContactRole[]

  @@unique([teamId, name])
  @@index([teamId])
}

model EventRegistration {
  id          String   @id @default(uuid()) @unique
  eventId     String
  event       Event    @relation(fields: [eventId], references: [id], onDelete: Cascade)
  contactId   String
  contact     Contact  @relation(fields: [contactId], references: [id], onDelete: Cascade)
  name        String   @db.VarChar(255)
  email       String   @db.VarChar(255)
  phone       String?  @db.VarChar(255)
  notes       String?  @db.Text
  customData  Json?    // Store additional registration form data as JSON
  createdAt   DateTime @default(now()) @db.Timestamptz(6)
  updatedAt   DateTime @updatedAt @db.Timestamptz(6)

  @@index([eventId])
  @@index([email])
  @@index([contactId])
}

enum EngagementDirection {
  INBOUND   // Message received by contact
  OUTBOUND  // Message sent to contact
}

enum EngagementSource {
  EMAIL
  PHONE
  SMS
  MEETING
  EVENT
  TODO
  OTHER
}

enum TodoStatus {
  PENDING
  IN_PROGRESS
  COMPLETED
  CANCELLED
}

model ContactEngagement {
  id          String               @id @default(uuid()) @unique
  contactId   String
  contact     Contact              @relation(fields: [contactId], references: [id], onDelete: Cascade)
  teamId      String
  direction   EngagementDirection
  source      EngagementSource
  subject     String?              @db.VarChar(500)
  message     String               @db.Text
  userId      String?              // Team user who sent/received the message
  userName    String?              @db.VarChar(255) // Store name for display even if user deleted

  // Todo-specific fields
  assignedToUserId String?          // User assigned to complete the todo
  assignedToUserName String?        @db.VarChar(255)
  todoStatus      TodoStatus?       // Status of the todo (only for TODO source)
  dueDate         DateTime?         @db.Timestamptz(6) // Due date for todos

  engagedAt   DateTime             @db.Timestamptz(6) // When the engagement occurred
  createdAt   DateTime             @default(now()) @db.Timestamptz(6)
  updatedAt   DateTime             @updatedAt @db.Timestamptz(6)

  @@index([contactId])
  @@index([teamId])
  @@index([engagedAt])
  @@index([assignedToUserId])
  @@index([todoStatus])
}

enum ChangeAction {
  CREATED
  UPDATED
  DELETED
}

model ContactChangeLog {
  id          String       @id @default(uuid()) @unique
  contactId   String
  contact     Contact      @relation(fields: [contactId], references: [id], onDelete: Cascade)
  action      ChangeAction
  fieldName   String?      @db.VarChar(255) // Field that changed (null for CREATE/DELETE)
  oldValue    String?      @db.Text         // Previous value (JSON for complex types)
  newValue    String?      @db.Text         // New value (JSON for complex types)
  metadata    Json?
  userId      String?      // User who made the change
  userName    String?      @db.VarChar(255) // Store name for display
  createdAt   DateTime     @default(now()) @db.Timestamptz(6)

  @@index([contactId])
  @@index([createdAt])
}

// Group and UserGroup models for access control
model Group {
  id                    String      @id @default(uuid()) @unique
  teamId                String
  team                  Teams       @relation(fields: [teamId], references: [id], onDelete: Cascade)
  name                  String      @db.VarChar(255)
  description           String?     @db.Text
  canAccessAllContacts  Boolean     @default(false)  // If true, users in this group can see all contacts
  isDefaultGroup        Boolean     @default(false)
  modulePermissions     GroupModulePermission[]
  createdAt             DateTime    @default(now()) @db.Timestamptz(6)
  updatedAt             DateTime    @updatedAt @db.Timestamptz(6)

  users       UserGroup[]
  contacts    Contact[]

  @@unique([teamId, name])
  @@index([teamId])
  @@index([teamId, isDefaultGroup])
}

model UserGroup {
  userId    String
  groupId   String
  user      User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  group     Group  @relation(fields: [groupId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now()) @db.Timestamptz(6)

  @@id([userId, groupId])
  @@index([userId])
  @@index([groupId])
}

model GroupModulePermission {
  id        String    @id @default(uuid()) @unique
  groupId   String
  group     Group     @relation(fields: [groupId], references: [id], onDelete: Cascade)
  module    AppModule
  createdAt DateTime  @default(now()) @db.Timestamptz(6)
  updatedAt DateTime  @updatedAt @db.Timestamptz(6)

  @@unique([groupId, module])
  @@index([groupId])
}
